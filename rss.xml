<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>YFun&#39;s Blog</title>
    <link>https://www.yfun.top/</link>
    
    <image>
      <url>https://www.yfun.top/icon.png</url>
      <title>YFun&#39;s Blog</title>
      <link>https://www.yfun.top/</link>
    </image>
    
    <atom:link href="https://www.yfun.top/rss.xml" rel="self" type="application/rss+xml"/>
    
    <description>探寻一切有趣的事物！</description>
    <pubDate>Fri, 22 Jan 2021 04:58:45 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>为你的网站加入深色模式</title>
      <link>https://www.yfun.top/posts/175456095.html</link>
      <guid>https://www.yfun.top/posts/175456095.html</guid>
      <pubDate>Fri, 22 Jan 2021 04:29:38 GMT</pubDate>
      
      <description>无意间看到 Sukka 大佬的文章：「你好黑暗，我的老朋友 —— 为网站添加用户友好的深色模式支持」，跟着文章重构了主题深色模式的代码，就转载过来方便学习。</description>
      
      
      
      <content:encoded><![CDATA[<div class="note note-info">            <div class="title">转载文章</div>原文标题：你好黑暗，我的老朋友 —— 为网站添加用户友好的深色模式支持<p>原文链接：<a href="https://blog.skk.moe/post/hello-darkmode-my-old-friend/">https://blog.skk.moe/post/hello-darkmode-my-old-friend/</a><br>原文作者：Sukka</p>          </div><p>前几天为我的 Hexo 主题：Miracle 加入了深色模式，但我的技术还是太辣鸡，经常出现问题。</p><p>无意间看到 Sukka 大佬的文章：「你好黑暗，我的老朋友 —— 为网站添加用户友好的深色模式支持」，跟着文章重构了主题深色模式的代码，就转载过来方便学习。</p><h2 id="什么是「深色模式」"><a href="#什么是「深色模式」" class="headerlink" title="什么是「深色模式」"></a>什么是「深色模式」</h2><p>很多操作系统在日落后会自动切换到「深色模式」、并不意味着「深色模式」就是「夜间模式」。「夜间模式」用于夜晚的弱光环境，主要目的是保护眼睛、减少强光刺激、避免影响睡眠，不难理解为什么 macOS 的 Night Shift 会自动调节屏幕色温、Android（AOSP）到了夜间可以选择启用系统级「琥珀色」滤镜。</p><p><img   class="lazyload-img" src="https://cdn.jsdelivr.net/npm/sks@0.0.6/macos-settings.png" srcset="https://cdn.jsdelivr.net/gh/HexoPlusPlus/CDN@db63c79/loading.gif" data-srcset="https://cdn.jsdelivr.net/npm/sks@0.0.6/macos-settings.png"  ></p><p>「深色模式」更像是一个主题，即使在白天也可以使用。不论是为了在 OLED 屏幕上省电、亦或是减少白光刺激护眼、亦或是暗色模式对色盲用户更加友好，总之 macOS 率先提出了系统级的「暗色模式」、并在 WebKit 中增加了对应的 Media Query，而后 Chromium、Firefox 先后跟进，如今兼容 <code>prefers-color-scheme</code> 的浏览器占有率已经高达 81.82%。</p><h2 id="利用-Media-Query-简单实现深色模式"><a href="#利用-Media-Query-简单实现深色模式" class="headerlink" title="利用 Media Query 简单实现深色模式"></a>利用 Media Query 简单实现深色模式</h2><p>CSS 媒体查询 <code>@media</code> 是一个足够强大的特性，可以有条件地将样式应用于文档和各种上下文中。<a href="https://drafts.csswg.org/mediaqueries-5/">Media Queries Level 5 草案</a> 中提出了深色模式的判断方式 <code>prefers-color-scheme</code>，包含 <code>light</code>、<code>dark</code>、<code>no-preference</code> 三种值。而不支持 Media Queries 5 的浏览器会直接无视 CSS 中的 <code>prefers-color-scheme</code> Media Query，无需额外的代码即可优雅降级。</p><p>还记得我刚刚说过「深色模式更像一个主题」么？为网站新增深色模式就如同换肤功能；搭配 <code>prefers-color-scheme</code>，编写深色模式的思路就如同编写响应式一般、无需赘述，结合几段 Code Snippet 一笔带过：</p><h3 id="CSS-Variable-的方法实现深色模式"><a href="#CSS-Variable-的方法实现深色模式" class="headerlink" title="CSS Variable 的方法实现深色模式"></a>CSS Variable 的方法实现深色模式</h3><pre><code class="hljs css"><span class="hljs-selector-pseudo">:root</span> &#123;  <span class="hljs-attribute">--text</span>: <span class="hljs-number">#333</span>;&#125;<span class="hljs-keyword">@media</span> (<span class="hljs-attribute">prefers-color-scheme:</span> dark) &#123;  <span class="hljs-selector-pseudo">:root</span> &#123;    <span class="hljs-attribute">--color-text</span>: <span class="hljs-number">#fff</span>;  &#125;&#125;<span class="hljs-selector-tag">body</span> &#123;  <span class="hljs-attribute">color</span>: <span class="hljs-built_in">var</span>(--color-text);&#125;</code></pre><p>通过维护两套 CSS Variable，可以快速切换不同的配色方案。这种方法特点是所需代码较少，缺点是 CSS Variable 的兼容性较差，可能还需要引入额外的 Polyfill。</p><h3 id="为深色模式单独编写样式"><a href="#为深色模式单独编写样式" class="headerlink" title="为深色模式单独编写样式"></a>为深色模式单独编写样式</h3><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;  <span class="hljs-attribute">color</span>: <span class="hljs-number">#333</span>;&#125;<span class="hljs-keyword">@media</span> (<span class="hljs-attribute">prefers-color-scheme:</span> dark) &#123;  <span class="hljs-selector-tag">body</span> &#123;    <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;  &#125;&#125;</code></pre><p>直接维护两套样式的方法清晰直观、任何网站都可以基于这种方法进行改造。但会造成冗余代码、较难实现统一的风格、后期不易维护。</p><h3 id="条件性加载深色模式的-CSS-文件"><a href="#条件性加载深色模式的-CSS-文件" class="headerlink" title="条件性加载深色模式的 CSS 文件"></a>条件性加载深色模式的 CSS 文件</h3><pre><code class="hljs css"><span class="hljs-comment">/* main.css */</span><span class="hljs-selector-tag">body</span> &#123;  <span class="hljs-attribute">color</span>: <span class="hljs-number">#333</span>;&#125;<span class="hljs-comment">/* dark.css */</span><span class="hljs-selector-tag">body</span> &#123;  <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;&#125;</code></pre><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;main.css&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;dark.css&quot;</span> <span class="hljs-attr">media</span>=<span class="hljs-string">&quot;(prefers-color-scheme: dark)&quot;</span>&gt;</span></code></pre><p>利用 <code>&lt;link&gt;</code> 标签的 Media Query，甚至可以单独加载暗色模式的 CSS 文件。</p><blockquote><p>需要注意 CSS 选择器的权重，因此作为可选的 <code>dark.css</code> 一定要放在 <code>main.css</code> 之后加载。</p></blockquote><p>除了上述三种方式以外，使用 CSS <code>filter</code> 或 <code>mix-blend-mode</code> 还可以实现对网站整体色调的改变，可以确保配色风格的统一性。</p><h2 id="「深色模式」的兼容性"><a href="#「深色模式」的兼容性" class="headerlink" title="「深色模式」的兼容性"></a>「深色模式」的兼容性</h2><p>虽然有了优雅的 <code>prefers-color-scheme</code> 可以识别操作系统的显示模式，但是对于用户来说，仅依赖 Media Query 的「深色模式」并不能带来很好的体验。<br>首先是浏览器兼容性。虽然支持该特性的浏览器的市场占有率非常喜人，但是从版本号上来看却并不乐观：</p><p><img   class="lazyload-img" src="https://cdn.jsdelivr.net/npm/sks@0.0.6/caniuse.png" srcset="https://cdn.jsdelivr.net/gh/HexoPlusPlus/CDN@db63c79/loading.gif" data-srcset="https://cdn.jsdelivr.net/npm/sks@0.0.6/caniuse.png"  ></p><p>考虑到使用 Chormium 70 内核甚至 Tencent X5 内核的国产浏览器，大部分用户并没有机会体验到深色模式。除此以外，操作系统级别的「深色模式」实现也会受到 OEM 厂商的影响 —— 虽然 Android 10（AOSP）提供「深色模式」，但是一加的 OxygenOS 却将其深藏在系统主题设置里，没有自动切换、在 Quick Settings 里也没有快速的切换开关。</p><h2 id="设计一个用户友好的「深色模式」"><a href="#设计一个用户友好的「深色模式」" class="headerlink" title="设计一个用户友好的「深色模式」"></a>设计一个用户友好的「深色模式」</h2><p>受限于兼容性和复杂的操作系统，大部分网站依然在使用更传统的「开关」切换 —— 通过 toggle <code>&lt;html&gt;</code> 或<br><code>&lt;body&gt;</code> 的 class 属性实现在两套样式之间切换、并将开关的状态记忆在 localStorage 中的方法虽然有效，却是无奈之举，手动切换开关相比 <code>prefers-color-scheme</code> 也不够优雅。如果将「开关」和 <code>prefers-color-scheme</code> 结合起来，就可以带来更好的用户体验：</p><ul><li>对于不兼容的浏览器或操作系统，访客依然可以通过开关手动切换显示模式</li><li>对于兼容的浏览器或操作系统，Media Query 能够实现在两种显示模式之间切换</li><li>在兼容的浏览器或操作系统上，用户还可以通过开关 override 当前的显示模式</li></ul><p>在将两者组合在一起时，不能简单地用「开关」覆盖 <code>prefers-color-scheme</code>，否则用户触发开关、状态被永久记忆在 localStorage 之后，就变成了僵硬的手动模式。<br>举个例子。访客可能在操作系统还没有自动切换到「深色模式」时通过网站上的开关切换显示模式，经过一个夜晚后到了次日白天、访客再度访问网站时，自然希望不需要再切换开关、网站就能以常规的浅色模式显示。因此设计思路是当 <code>prefers-color-scheme</code> 的值发生改变（从 与用户需要的显示模式不同 变成 相同）时清空 localStorage 中储存的开关状态，此时显示模式切换回基于 Media Query 的「自动」模式。</p><p><strong>Talk is cheap, here goes the code.</strong></p><p>首先是 CSS：</p><pre><code class="hljs css"><span class="hljs-selector-pseudo">:root</span> &#123;  <span class="hljs-attribute">--color-mode</span>: <span class="hljs-string">&#x27;light&#x27;</span>;  <span class="hljs-attribute">--text</span>: <span class="hljs-number">#333</span>;&#125;<span class="hljs-keyword">@media</span> (<span class="hljs-attribute">prefers-color-scheme:</span> dark) &#123;  <span class="hljs-selector-pseudo">:root</span> &#123;    <span class="hljs-attribute">--color-mode</span>: <span class="hljs-string">&#x27;dark&#x27;</span>;  &#125;  <span class="hljs-selector-pseudo">:root</span><span class="hljs-selector-pseudo">:not(</span><span class="hljs-selector-attr">[data-user-color-scheme]</span>) &#123;    <span class="hljs-attribute">--text</span>: <span class="hljs-number">#eff</span>;  &#125;&#125;<span class="hljs-selector-attr">[data-user-color-scheme=<span class="hljs-string">&#x27;dark&#x27;</span>]</span> &#123;  <span class="hljs-attribute">--text</span>: <span class="hljs-number">#eff</span>;&#125;<span class="hljs-selector-tag">body</span> &#123;  <span class="hljs-attribute">color</span>: <span class="hljs-built_in">var</span>(--color-text);&#125;</code></pre><p>真是令人看的头大，让我们逐行来看都是些什么：</p><ul><li>在 <code>:root</code> 下定义了一个 CSS Variable <code>--color-mode: light</code> 和在浅色模式下用到的 CSS Variable（比如使用深色 <code>#333</code> 作为主要字体颜色）。</li><li>使用 <code>prefers-color-scheme</code> 的 Media Query 定义深色模式下的 CSS Variable： <code>--color-mode: light</code> 。深色模式的样式（如浅色 <code>#eff</code> 作为主要字体颜色）要定义在 <code>:not([data-user-color-scheme])</code> 伪类下以避免「开关」的行为覆盖浏览器的样式。</li><li>为 <code>[data-user-color-scheme=&#39;dark&#39;]</code> 再定义一遍深色模式下用到的样式。<br>有了这段 CSS，不难理解深色模式何时会生效：当操作系统使用「深色模式」且 <code>&lt;html&gt;</code> 或 <code>&lt;body&gt;</code> 标签上没有 <code>data-user-color-scheme</code> 属性时、或者存在 <code>data-user-color-scheme</code> 属性且值为 <code>dark</code> 时。</li></ul><p>然后是困难的部分了：编写 JavaScript 为「开关」添加行为。</p><p>先定义一些常量：</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> rootElement = <span class="hljs-built_in">document</span>.documentElement; <span class="hljs-comment">// &lt;html&gt;</span><span class="hljs-keyword">const</span> darkModeStorageKey = <span class="hljs-string">&#x27;user-color-scheme&#x27;</span>; <span class="hljs-comment">// 作为 localStorage 的 key</span><span class="hljs-keyword">const</span> darkModeMediaQueryKey = <span class="hljs-string">&#x27;--color-mode&#x27;</span>;<span class="hljs-keyword">const</span> rootElementDarkModeAttributeName = <span class="hljs-string">&#x27;data-user-color-scheme&#x27;</span>;<span class="hljs-keyword">const</span> darkModeTogglebuttonElement = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-comment">/* element id */</span>);</code></pre><p>接下来，用 <code>try &#123;&#125; catch (e) &#123;&#125;</code> 封装一下 localStorage 的操作，以应对 HTML5 Storage 被禁用、localStorage 被写满、localStorage 实现不完整的情况：</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> setLS = <span class="hljs-function">(<span class="hljs-params">k, v</span>) =&gt;</span> &#123;  <span class="hljs-keyword">try</span> &#123;    <span class="hljs-built_in">localStorage</span>.setItem(k, v);  &#125; <span class="hljs-keyword">catch</span> (e) &#123; &#125;&#125;<span class="hljs-keyword">const</span> removeLS = <span class="hljs-function">(<span class="hljs-params">k</span>) =&gt;</span> &#123;  <span class="hljs-keyword">try</span> &#123;    <span class="hljs-built_in">localStorage</span>.removeItem(k);  &#125; <span class="hljs-keyword">catch</span> (e) &#123; &#125;&#125;<span class="hljs-keyword">const</span> getLS = <span class="hljs-function">(<span class="hljs-params">k</span>) =&gt;</span> &#123;  <span class="hljs-keyword">try</span> &#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">localStorage</span>.getItem(k);  &#125; <span class="hljs-keyword">catch</span> (e) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span> <span class="hljs-comment">// 与 localStorage 中没有找到对应 key 的行为一致</span>  &#125;&#125;</code></pre><p>我们还需要一个函数读取当前 <code>prefers-color-scheme</code> 的方法。由于已经在 CSS 中定义了 <code>--color-mode</code>，所以在 JS 中直接读取就好了：</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> getModeFromCSSMediaQuery = <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-keyword">const</span> res = getComputedStyle(rootElement).getPropertyValue(darkModeMediaQueryKey);  <span class="hljs-keyword">if</span> (res.length) <span class="hljs-keyword">return</span> res.replace(<span class="hljs-regexp">/\&quot;/g</span>, <span class="hljs-string">&#x27;&#x27;</span>).trim();  <span class="hljs-keyword">return</span> res === <span class="hljs-string">&#x27;dark&#x27;</span> ? <span class="hljs-string">&#x27;dark&#x27;</span> : <span class="hljs-string">&#x27;light&#x27;</span>;    <span class="hljs-comment">// 使用 matchMedia API 的写法会优雅的多</span>  <span class="hljs-comment">// return window.matchMedia(&#x27;(prefers-color-scheme: dark)&#x27;).matches ? &#x27;dark&#x27; : &#x27;light&#x27;</span>&#125;</code></pre><p>还记得我们需要自动取消手动模式回到 <code>prefers-color-scheme</code> 么？意味着我们需要一个函数清掉 LS、删掉 <code>&lt;html&gt;</code> 存在的 <code>data-user-color-scheme</code> 属性：</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> resetRootDarkModeAttributeAndLS = <span class="hljs-function">() =&gt;</span> &#123;  rootElement.removeAttribute(rootElementDarkModeAttributeName);  removeLS(darkModeStorageKey);&#125;</code></pre><p>接下来是起主要作用的函数了，负责为 <code>&lt;html&gt;</code> 标签修改 <code>data-user-color-scheme</code> 属性：</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> validColorModeKeys = &#123;  <span class="hljs-string">&#x27;dark&#x27;</span>: <span class="hljs-literal">true</span>,  <span class="hljs-string">&#x27;light&#x27;</span>: <span class="hljs-literal">true</span>&#125;<span class="hljs-keyword">const</span> applyCustomDarkModeSettings = <span class="hljs-function">(<span class="hljs-params">mode</span>) =&gt;</span> &#123;  <span class="hljs-comment">// 接受从「开关」处传来的模式，或者从 localStorage 读取</span>  <span class="hljs-keyword">const</span> currentSetting = mode || getLS(darkModeStorageKey);  <span class="hljs-keyword">if</span> (currentSetting === getModeFromCSSMediaQuery()) &#123;    <span class="hljs-comment">// 当用户自定义的显示模式和 prefers-color-scheme 相同时重置、恢复到自动模式</span>    resetRootDarkModeAttributeAndLS();  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (validColorModeKeys[currentSetting]) &#123; <span class="hljs-comment">// 相比 Array#indexOf，这种写法 Uglify 后字节数更少</span>    rootElement.setAttribute(rootElementDarkModeAttributeName, currentSetting);  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">// 首次访问或从未使用过开关、localStorage 中没有存储的值，currentSetting 是 null</span>    <span class="hljs-comment">// 或者 localStorage 被篡改，currentSetting 不是合法值</span>    resetRootDarkModeAttributeAndLS();  &#125;&#125;</code></pre><p>当然，「开关」还需要一个函数，这个函数负责获取相反的显示模式，同时还要将新的模式写入 localStorage 存储起来：</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> invertDarkModeObj = &#123;  <span class="hljs-string">&#x27;dark&#x27;</span>: <span class="hljs-string">&#x27;light&#x27;</span>,  <span class="hljs-string">&#x27;light&#x27;</span>: <span class="hljs-string">&#x27;dark&#x27;</span>&#125;<span class="hljs-keyword">const</span> toggleCustomDarkMode = <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-keyword">let</span> currentSetting = getLS(darkModeStorageKey);    <span class="hljs-keyword">if</span> (validColorModeKeys[currentSetting]) &#123;    <span class="hljs-comment">// 从 localStorage 中读取模式，并取相反的模式</span>    currentSetting = invertDarkModeObj[currentSetting];  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (currentSetting === <span class="hljs-literal">null</span>) &#123;    <span class="hljs-comment">// localStorage 中没有相关值，或者 localStorage 抛了 Error</span>    <span class="hljs-comment">// 从 CSS 中读取当前 prefers-color-scheme 并取相反的模式</span>    currentSetting = invertDarkModeObj[getModeFromCSSMediaQuery()];  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">// 不知道出了什么幺蛾子，比如 localStorage 被篡改成非法值</span>    <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 直接 return;</span>  &#125;  <span class="hljs-comment">// 将相反的模式写入 localStorage</span>  setLS(darkModeStorageKey, currentSetting);  <span class="hljs-keyword">return</span> currentSetting;&#125;</code></pre><p>相关的函数都定义完了，是时候添加函数执行了：</p><pre><code class="hljs js"><span class="hljs-comment">// 当页面加载时，将显示模式设置为 localStorage 中自定义的值（如果有的话）</span>applyCustomDarkModeSettings();darkModeTogglebuttonElement.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-comment">// 当用户点击「开关」时，获得新的显示模式、写入 localStorage、并在页面上生效</span>  applyCustomDarkModeSettings(toggleCustomDarkMode());&#125;)</code></pre><p>我的博客也使用的这种实现，通过 Navbar 中的按钮体验一下吧！</p><div class="note note-info">            <div class="title">转载文章</div>原文标题：你好黑暗，我的老朋友 —— 为网站添加用户友好的深色模式支持<p>原文链接：<a href="https://blog.skk.moe/post/hello-darkmode-my-old-friend/">https://blog.skk.moe/post/hello-darkmode-my-old-friend/</a><br>原文作者：Sukka</p>          </div>]]></content:encoded>
      
      
      <category domain="https://www.yfun.top/categories/%E6%9E%81%E5%AE%A2/">极客</category>
      
      
      <category domain="https://www.yfun.top/tags/%E5%8D%9A%E5%AE%A2/">博客</category>
      
      <category domain="https://www.yfun.top/tags/Web/">Web</category>
      
      <category domain="https://www.yfun.top/tags/JavaScript/">JavaScript</category>
      
      <category domain="https://www.yfun.top/tags/CSS/">CSS</category>
      
      
      <comments>https://www.yfun.top/posts/175456095.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>懒加载你的评论插件</title>
      <link>https://www.yfun.top/posts/270988717.html</link>
      <guid>https://www.yfun.top/posts/270988717.html</guid>
      <pubDate>Fri, 22 Jan 2021 03:35:05 GMT</pubDate>
      
      <description>使用懒加载优化你的评论插件</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>打开博客的文章页面，加载完毕就花费了一秒多的时长，打开控制台一看：</p><p><img   class="lazyload-img" src="https://7.dusays.com/2021/01/22/4478a892ab136.png" srcset="https://cdn.jsdelivr.net/gh/HexoPlusPlus/CDN@db63c79/loading.gif" data-srcset="https://7.dusays.com/2021/01/22/4478a892ab136.png"  alt="全是表情包" ></p><blockquote><p>全是评论的表情包</p></blockquote><p>再加上之前使用的是 Valine + LeanCloud 国际版，更是拖慢速度。</p><p>我就决定懒加载评论插件，在评论区进入（或即将进入）可视范围时再加载。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><div class="note note-info">            <div class="title">提示</div>目前仅测试了 Twikoo 评论系统，其它评论系统理论上应该同样适用。          </div><h3 id="修改评论区代码"><a href="#修改评论区代码" class="headerlink" title="修改评论区代码"></a>修改评论区代码</h3><p>找到并修改你的评论区代码，将原先的评论区代码放入 <code>raw</code> 属性值中，此处仅提供示例参考：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/twikoo@1.0.0/dist/twikoo.all.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;lazyload-comment&quot;</span> <span class="hljs-attr">raw</span>=<span class="hljs-string">&#x27;</span></span><span class="hljs-tag"><span class="hljs-string">&lt;!-- 将原先的评论区代码放入 `raw` 属性值中 --&gt;</span></span><span class="hljs-tag"><span class="hljs-string">&lt;!-- 注意：引入的评论插件代码文件不要懒加载，避免报错 --&gt;</span></span><span class="hljs-tag"><span class="hljs-string">&lt;div id=&quot;tcomment&quot;&gt;&lt;/div&gt;</span></span><span class="hljs-tag"><span class="hljs-string">&lt;script&gt;</span></span><span class="hljs-tag"><span class="hljs-string">    twikoo.init(&#123;</span></span><span class="hljs-tag"><span class="hljs-string">        envId: &quot;your-env-id&quot;,</span></span><span class="hljs-tag"><span class="hljs-string">        el: &quot;#tcomment&quot;,</span></span><span class="hljs-tag"><span class="hljs-string">        region: &quot;ap-guangzhou&quot;,</span></span><span class="hljs-tag"><span class="hljs-string">        path: &quot;window.location.pathname&quot;</span></span><span class="hljs-tag"><span class="hljs-string">    &#125;);</span></span><span class="hljs-tag"><span class="hljs-string">&lt;/script&gt;</span></span><span class="hljs-tag"><span class="hljs-string">&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><div class="note note-warning">            <div class="title">注意</div>引入的代码文件不要懒加载，避免报错。          </div><h3 id="JS-实现懒加载"><a href="#JS-实现懒加载" class="headerlink" title="JS 实现懒加载"></a>JS 实现懒加载</h3><div class="note note-info">            <div class="title">提示</div>我这里给出的代码依赖 jQuery，因为我使用了它的选择器和一些 API，一定程度上会方便很多。<br/>实际上原生 JS 也是可以达到同样的效果。          </div><p>使用 jQuery 选择页面中的懒加载元素：</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> content = $(<span class="hljs-string">&quot;#lazyload-comment&quot;</span>);</code></pre><p>再获取页面高度等数据，循环寻找出页面中所有的懒加载元素。</p><p>如果元素所在高度 小于等于 可见高度，就代表元素是可见的。</p><p>如果元素可见，就检查当前的内容是否被标记为已加载，避免重复的加载耗费资源。</p><p>如果未加载，就从 <code>raw</code> 属性中获取值，将其添加至 HTML 内容。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">load</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-comment">// 获取页面高度等数据</span>    <span class="hljs-keyword">var</span> scrollTop = <span class="hljs-built_in">document</span>.body.scrollTop || <span class="hljs-built_in">document</span>.documentElement.scrollTop;    <span class="hljs-keyword">var</span> winTop = <span class="hljs-built_in">window</span>.innerHeight;    <span class="hljs-comment">// For 循环寻找出页面中所有的懒加载元素</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; content.length; i++) &#123;        <span class="hljs-comment">// 如果元素所在高度 小于等于 窗口高度+滚动高度 (可见高度)</span>        <span class="hljs-keyword">if</span> (content[i].offsetTop &lt;= scrollTop + winTop) &#123;            <span class="hljs-comment">// 如果当前的内容没有被标记为已加载</span>            <span class="hljs-keyword">if</span> (!content.attr(<span class="hljs-string">&quot;load&quot;</span>)) &#123;                <span class="hljs-comment">// 从 RAW 属性中获取值</span>                <span class="hljs-keyword">var</span> pageContentRaw = content.attr(<span class="hljs-string">&quot;raw&quot;</span>);                <span class="hljs-comment">// 将其添加至 HTML 内容</span>                $(content[i]).html(pageContentRaw);                content.attr(<span class="hljs-string">&quot;load&quot;</span>,<span class="hljs-literal">true</span>);            &#125;        &#125;    &#125;&#125;</code></pre><p>在页面刚加载完毕的时候先执行一次。再当页面滚动的时候重复执行。</p><pre><code class="hljs js"><span class="hljs-comment">// 页面加载时先执行一次</span>load();<span class="hljs-comment">// 当页面滚动的时候执行</span><span class="hljs-built_in">window</span>.onscroll = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    load();&#125;</code></pre><blockquote><p>别忘了在页面中引入这个 JS！</p></blockquote><p>可以看看：<a href="/test/lazyload-the-comment.html/">演示页面</a></p>]]></content:encoded>
      
      
      <category domain="https://www.yfun.top/categories/%E6%9E%81%E5%AE%A2/">极客</category>
      
      
      <category domain="https://www.yfun.top/tags/%E5%8D%9A%E5%AE%A2/">博客</category>
      
      <category domain="https://www.yfun.top/tags/Web/">Web</category>
      
      <category domain="https://www.yfun.top/tags/JavaScript/">JavaScript</category>
      
      
      <comments>https://www.yfun.top/posts/270988717.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>JavaScript 为你的网页图片加入懒加载</title>
      <link>https://www.yfun.top/posts/421506333.html</link>
      <guid>https://www.yfun.top/posts/421506333.html</guid>
      <pubDate>Fri, 15 Jan 2021 03:46:00 GMT</pubDate>
      
      <description>懒加载在前端性能优化方面已经是一个的老生常谈的话题了，不妨自己写个？</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>我们设置 <code>srcset</code> 为加载的动画，<code>src</code> 与 <code>data-srcset</code> 为真实的图片。</p><p>当图片在页面的可见范围内的时候，则将 <code>data-srcset</code> 的值更新到 <code>srcset</code> 中，否则不更新。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><p>我们新建一个 HTML 页面，随意输入一些文字用于占位，再在这些文字中加入些图片。</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>    登上微博热搜的必应推送壁纸是什么意思？多国专家懵了必应推送壁纸是怎么一回事？必应推送壁纸是什么梗？必应推送壁纸最近为什么这么火呢？说到必应推送壁纸大家肯定都不陌生，但是你知道必应推送壁纸到底是什么吗？相信大家对必应推送壁纸都很熟悉，必应推送壁纸就是我们每天都会经常遇到的，但是必应推送壁纸是怎么回事呢？必应推送壁纸最近能火，其实就是必应推送壁纸受到了大家的关注。大家可能会感到很惊讶，必应推送壁纸为什么是这样的？必应推送壁纸究竟为什么火起来了呢？但事实就是这样，小编也感到非常惊讶。以上就是小编为大家带来的的关于必应推送壁纸是什么意思，必应推送壁纸是什么梗的内容。欢迎大家在评论区和小编一起讨论，畅所欲言。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> </span><span class="hljs-tag">    <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;src/img/1.jpg&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">srcset</span>=<span class="hljs-string">&quot;src/img/loading.svg&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">data-srcset</span>=<span class="hljs-string">&quot;src/img/1.jpg&quot;</span></span><span class="hljs-tag">&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>    什么是必应每日推送精美壁纸？只有1%的人答得上来！你知道必应每日推送精美壁纸吗？必应每日推送精美壁纸最近为什么这么火？大家都知道，现代社会中随着人们生活水平的提高，必应每日推送精美壁纸如今也成为了人们茶余饭后的谈资。相信大家对必应每日推送精美壁纸都很熟悉，必应每日推送精美壁纸就是我们每天都会经常遇到的，但是必应每日推送精美壁纸是怎么回事呢？今天小编就带大家来看看究竟是怎么一回事。必应每日推送精美壁纸最近能火，其实就是必应每日推送精美壁纸受到了大家的关注。大家可能会感到很惊讶，必应每日推送精美壁纸为什么是这样的？必应每日推送精美壁纸究竟为什么火起来了呢？但事实就是这样，小编也感到非常惊讶。那么以上就是今天小编为大家整理的关于必应每日推送精美壁纸是什么梗，必应每日推送精美壁纸为什么火的原因。如果大家喜欢，可以点赞表示对小编的支持。欢迎在下方评论和小编一起讨论喔<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> </span><span class="hljs-tag">    <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;src/img/2.jpg&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">srcset</span>=<span class="hljs-string">&quot;src/img/loading.svg&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">data-srcset</span>=<span class="hljs-string">&quot;src/img/2.jpg&quot;</span></span><span class="hljs-tag">&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>    登上微博热搜的必应推送壁纸是什么意思？多国专家懵了必应推送壁纸是怎么一回事？必应推送壁纸是什么梗？必应推送壁纸最近为什么这么火呢？说到必应推送壁纸大家肯定都不陌生，但是你知道必应推送壁纸到底是什么吗？相信大家对必应推送壁纸都很熟悉，必应推送壁纸就是我们每天都会经常遇到的，但是必应推送壁纸是怎么回事呢？必应推送壁纸最近能火，其实就是必应推送壁纸受到了大家的关注。大家可能会感到很惊讶，必应推送壁纸为什么是这样的？必应推送壁纸究竟为什么火起来了呢？但事实就是这样，小编也感到非常惊讶。以上就是小编为大家带来的的关于必应推送壁纸是什么意思，必应推送壁纸是什么梗的内容。欢迎大家在评论区和小编一起讨论，畅所欲言。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> </span><span class="hljs-tag">    <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;src/img/3.jpg&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">srcset</span>=<span class="hljs-string">&quot;src/img/loading.svg&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">data-srcset</span>=<span class="hljs-string">&quot;src/img/3.jpg&quot;</span></span><span class="hljs-tag">&gt;</span></code></pre><h3 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h3><p>我这里给出的代码依赖 <code>jQuery</code>，因为我使用了它的选择器，一定程度上会方便很多。</p><p>一些代码的细节全在注释里了。</p><pre><code class="hljs js"><span class="hljs-comment">// 使用 jQuery 选择页面中的懒加载元素</span><span class="hljs-keyword">var</span> content = $(<span class="hljs-string">&quot;img&quot;</span>);<span class="hljs-comment">// 预先加载，0 为不预先加载，数字越大将会越提前加载。</span><span class="hljs-keyword">var</span> preload = <span class="hljs-number">0</span>$(<span class="hljs-built_in">document</span>).ready(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">load</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-comment">// 获取页面高度等数据</span>        <span class="hljs-keyword">var</span> scrollTop = <span class="hljs-built_in">document</span>.body.scrollTop || <span class="hljs-built_in">document</span>.documentElement.scrollTop;        <span class="hljs-keyword">var</span> winTop = <span class="hljs-built_in">window</span>.innerHeight;        <span class="hljs-comment">// For 循环寻找出页面中所有的懒加载元素</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; content.length; i++) &#123;            <span class="hljs-comment">// 如果元素所在高度 小于等于 窗口高度+滚动高度 (可见高度)</span>            <span class="hljs-keyword">if</span> (content[i].offsetTop &lt;= scrollTop + winTop + preload) &#123;                <span class="hljs-comment">// 如果当前的内容没有被标记为已加载</span>                <span class="hljs-keyword">if</span> (!$(content[i]).attr(<span class="hljs-string">&quot;load&quot;</span>)) &#123;                    <span class="hljs-comment">// 从 data-srcset 属性中获取值</span>                    <span class="hljs-keyword">var</span> pageContentRaw = $(content[i]).attr(<span class="hljs-string">&quot;data-srcset&quot;</span>);                    <span class="hljs-comment">// 将其更新至 srcset 属性中</span>                    $(content[i]).attr(<span class="hljs-string">&#x27;srcset&#x27;</span>,pageContentRaw);                    $(content[i]).attr(<span class="hljs-string">&quot;load&quot;</span>,<span class="hljs-literal">true</span>);                &#125;            &#125;        &#125;    &#125;    <span class="hljs-comment">// 页面加载时先执行一次</span>    load();    <span class="hljs-comment">// 当页面滚动的时候执行</span>    <span class="hljs-built_in">window</span>.onscroll = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        load();    &#125;&#125;);</code></pre>]]></content:encoded>
      
      
      <category domain="https://www.yfun.top/categories/%E6%9E%81%E5%AE%A2/">极客</category>
      
      
      <category domain="https://www.yfun.top/tags/%E5%8D%9A%E5%AE%A2/">博客</category>
      
      <category domain="https://www.yfun.top/tags/Web/">Web</category>
      
      <category domain="https://www.yfun.top/tags/JavaScript/">JavaScript</category>
      
      
      <comments>https://www.yfun.top/posts/421506333.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>博客更换新主题</title>
      <link>https://www.yfun.top/posts/1987652759.html</link>
      <guid>https://www.yfun.top/posts/1987652759.html</guid>
      <pubDate>Wed, 13 Jan 2021 10:15:49 GMT</pubDate>
      
      <description>经过近一个月的开发，Miracle 主题已经发布至 v1.2.0 版本，也正式可以开始使用。</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>经过近一个月的开发，Miracle 主题已经发布至 <code>v1.2.0</code> 版本，也正式可以开始使用。</p><p>主题仓库：<a href="https://github.com/hifun-team/hexo-theme-miracle">hifun-team/hexo-theme-miracle</a></p><p>主题对输出的内容等进行优化，去除不必要的资源，速度非常之快。</p><p>Google PageSpeed 的移动得分可以达到 99 分，也是不错的成绩。</p><blockquote><p>PS: 主要原因是主题的首页没有图片，这主要是因为我不想找图，而且会拖慢页面速度，一举两等。[doge]</p></blockquote><h2 id="评论"><a href="#评论" class="headerlink" title="评论"></a>评论</h2><p>评论更换为 Waline，这样我就有了评论后台、回复通知和关键词过滤，真不错！</p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>部署换回了直接部署 ( <code>hexo d</code> )，因为主题在 <code>Action</code> 部署时一直无法解析 <code>Tag 插件</code>，而本地又可以…</p><p>而且实际上使用云部署的次数并不多，因为我每次写完文章以后都会自己看一遍，不太必要。</p>]]></content:encoded>
      
      
      <category domain="https://www.yfun.top/categories/%E5%8D%9A%E5%AE%A2/">博客</category>
      
      
      <category domain="https://www.yfun.top/tags/%E5%8D%9A%E5%AE%A2/">博客</category>
      
      
      <comments>https://www.yfun.top/posts/1987652759.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>使用 CloudFlare 加速你的网站</title>
      <link>https://www.yfun.top/posts/995700211.html</link>
      <guid>https://www.yfun.top/posts/995700211.html</guid>
      <pubDate>Tue, 15 Dec 2020 08:19:29 GMT</pubDate>
      
      <description>使用免费 CDN 服务 CloudFlare 为你的网站提速。</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>CloudFlare 为我们提供了免费的 CDN 服务，并拥有全球各地的优秀节点，作为<strong>国外比较优秀</strong>的 CDN 服务商。</p><p>但是，来自国内的访问都会被 CloudFlare 绕到大洋彼岸的美国。再加上某神秘的阻碍，导致在国内的访问一直不是很好。Ping 出延迟基本大于 &gt;= 200ms 。</p><p>在一次偶然的机会中，发现：</p><ul><li>CloudFlare 拥有很多节点。</li><li>CloudFlare 的节点之间速度非常之快。</li><li>CloudFlare 的节点之间几乎没有延迟。</li><li>CloudFlare 所有节点均免费，基本可以随便接入。</li></ul><hr><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>既然发现了这个好办法，那么就开始实践吧！</p><p>首先，前往「CloudFlare Partner」的站点登录。</p><blockquote><p>这里要注意！CloudFlare 官方已经停止 CNAME 接入，只能前往「CloudFlare Partner」接入。</p></blockquote><p>以 <a href="https://cdn.moeelf.com/">萌精灵 CDN</a> 为例，打开其官网：<a href="https://cdn.moeelf.com/">https://cdn.moeelf.com/</a> 并登录你的 CloudFlare 账号。</p><p>然后点击页面右上角的「添加域名」并加你的域名接入 CloudFlare 。</p><p><img   class="lazyload-img" src="https://cdn.jsdelivr.net/gh/MyBlog-GitHub/image-upload@main/uPic/hPX5DZ.png" srcset="https://cdn.jsdelivr.net/gh/HexoPlusPlus/CDN@db63c79/loading.gif" data-srcset="https://cdn.jsdelivr.net/gh/MyBlog-GitHub/image-upload@main/uPic/hPX5DZ.png"  alt="添加域名" ></p><p>输入域名并点击「添加」即可添加成功。</p><p>接下来点击主页列表里的「管理 DNS」进入管理界面。</p><p><img   class="lazyload-img" src="https://cdn.jsdelivr.net/gh/MyBlog-GitHub/image-upload@main/uPic/mLAxAy.png" srcset="https://cdn.jsdelivr.net/gh/HexoPlusPlus/CDN@db63c79/loading.gif" data-srcset="https://cdn.jsdelivr.net/gh/MyBlog-GitHub/image-upload@main/uPic/mLAxAy.png"  alt="管理 DNS" ></p><p>接下来点击「添加新记录」添加一个新的记录。</p><p><img   class="lazyload-img" src="https://cdn.jsdelivr.net/gh/MyBlog-GitHub/image-upload@main/uPic/UqyfQI.png" srcset="https://cdn.jsdelivr.net/gh/HexoPlusPlus/CDN@db63c79/loading.gif" data-srcset="https://cdn.jsdelivr.net/gh/MyBlog-GitHub/image-upload@main/uPic/UqyfQI.png"  alt="添加记录" ></p><p><img   class="lazyload-img" src="https://cdn.jsdelivr.net/gh/MyBlog-GitHub/image-upload@main/uPic/F0QTaI.png" srcset="https://cdn.jsdelivr.net/gh/HexoPlusPlus/CDN@db63c79/loading.gif" data-srcset="https://cdn.jsdelivr.net/gh/MyBlog-GitHub/image-upload@main/uPic/F0QTaI.png"  alt="参考" ></p><p>然后进入你域名的 DNS 管理系统，注意是解析域名的地方。</p><p>找到「CNAME 接入」处的对应 CNAME 地址，将其设为相应的解析地址。</p><hr><h2 id="加速访问"><a href="#加速访问" class="headerlink" title="加速访问"></a>加速访问</h2><p>虽然默认提供给我们的节点很慢，但我们可以从 CloudFlare 公开的节点中寻找访问速度快的节点。</p><p>我找到了几个国内速度不错的节点，可以参考参考：</p><table><thead><tr><th>IP 地址</th><th>运营商</th></tr></thead><tbody><tr><td>104.27.169.248</td><td>默认</td></tr><tr><td>104.19.19.119</td><td>移动</td></tr><tr><td>141.101.115.11</td><td>移动</td></tr><tr><td>104.16.245.1</td><td>联通</td></tr><tr><td>104.16.246.1</td><td>联通</td></tr><tr><td>104.20.157.19</td><td>电信</td></tr><tr><td>141.101.114.202</td><td>电信</td></tr></tbody></table><p>然后再将原来的 CNAME 记录改为 A 记录到以上 IP，再配合智能运营商解析，达到提速。</p><p>如果你不想一个一个设置，可以直接将「默认」记录指向 <code>cf.record.yfun.top</code> ，节点基本都是上面的，但偶尔会改变。</p><p>可能会遇到的情况：<a href="#%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8%E7%AD%BE%E5%8F%91-SSL-%E8%AF%81%E4%B9%A6%EF%BC%9F">无法正常签发 SSL 证书</a></p><hr><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="无法正常签发-SSL-证书？"><a href="#无法正常签发-SSL-证书？" class="headerlink" title="无法正常签发 SSL 证书？"></a>无法正常签发 SSL 证书？</h3><p>CloudFlare 默认会提供免费 SSL 证书服务，但使用「加速节点」可能导致无法正确签发。</p><p>解决方法：使用智能 DNS，将「境外」的记录解析至控制面板提供给您的官方地址。</p><hr><h3 id="开启-SSL-后访问错误？"><a href="#开启-SSL-后访问错误？" class="headerlink" title="开启 SSL 后访问错误？"></a>开启 SSL 后访问错误？</h3><p>试着为源站配置 SSL 证书，然后前往官方控制台（<a href="https://dash.cloudflare.com/">https://dash.cloudflare.com</a>）将域名的 SSL 设为「完全」。</p><p>注意：使用「完全」方式请务必确定源站已开启 SSL！</p><hr><h2 id="速度"><a href="#速度" class="headerlink" title="速度"></a>速度</h2><pre><code class="hljs bash">PING cf.record.yfun.top (141.101.115.11): 56 data bytes64 bytes from 141.101.115.11: icmp_seq=0 ttl=52 time=17.007 ms64 bytes from 141.101.115.11: icmp_seq=1 ttl=52 time=16.363 ms64 bytes from 141.101.115.11: icmp_seq=2 ttl=52 time=21.385 ms64 bytes from 141.101.115.11: icmp_seq=3 ttl=52 time=19.305 ms64 bytes from 141.101.115.11: icmp_seq=4 ttl=52 time=16.341 ms64 bytes from 141.101.115.11: icmp_seq=5 ttl=52 time=23.181 ms64 bytes from 141.101.115.11: icmp_seq=6 ttl=52 time=18.888 ms64 bytes from 141.101.115.11: icmp_seq=7 ttl=52 time=18.087 ms64 bytes from 141.101.115.11: icmp_seq=8 ttl=52 time=16.153 ms64 bytes from 141.101.115.11: icmp_seq=9 ttl=52 time=19.363 ms--- cf.record.yfun.top ping statistics ---10 packets transmitted, 10 packets received, 0.0% packet lossround-trip min/avg/max/stddev = 16.153/18.607/23.181/2.209 ms</code></pre>]]></content:encoded>
      
      
      <category domain="https://www.yfun.top/categories/%E6%9E%81%E5%AE%A2/">极客</category>
      
      
      <category domain="https://www.yfun.top/tags/%E5%8D%9A%E5%AE%A2/">博客</category>
      
      <category domain="https://www.yfun.top/tags/CDN/">CDN</category>
      
      <category domain="https://www.yfun.top/tags/CloudFlare/">CloudFlare</category>
      
      
      <comments>https://www.yfun.top/posts/995700211.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>利用 GitHub Action 自动部署 Hexo 博客</title>
      <link>https://www.yfun.top/posts/2241387868.html</link>
      <guid>https://www.yfun.top/posts/2241387868.html</guid>
      <pubDate>Sun, 29 Nov 2020 07:45:00 GMT</pubDate>
      
      <description>利用 GitHub Action 自动部署 Hexo 博客，随时随地更改博客文件。</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>使用 Hexo 写博客，每次写完都要生成静态文件，而且 Hexo 基于 <code>Node.JS</code>，不能再手机上更新。</p><p>所以每次提交过后发现自己码错字了，或是有同学来换友链，总是要麻烦的改文件，再上传。</p><p>那么，Hexo 如何进行在线更新呢？</p><p>如果使用服务器的话，就丧失了使用 Hexo 的最大的优点——节省开支，而且还不如用 <code>Typecho/WordPress</code> 呢。</p><p>后来突然想到 <code>GitHub Action</code> 可以实现在线打包等操作，就想试试在线生成 Hexo 博客。</p><hr><h1 id="行动"><a href="#行动" class="headerlink" title="行动"></a>行动</h1><h2 id="获取-GitHub-令牌"><a href="#获取-GitHub-令牌" class="headerlink" title="获取 GitHub 令牌"></a>获取 GitHub 令牌</h2><p>登录你的 GitHub 账号，点击右上角的头像，点击「Settings」进入设置。</p><p><img   class="lazyload-img" src="https://cdn.jsdelivr.net/gh/MyBlog-GitHub/image-upload@main/uPic/2rxI7G.png" srcset="https://cdn.jsdelivr.net/gh/HexoPlusPlus/CDN@db63c79/loading.gif" data-srcset="https://cdn.jsdelivr.net/gh/MyBlog-GitHub/image-upload@main/uPic/2rxI7G.png"  alt="设置" ></p><p>点击菜单栏中的「Developer settings」进入开发者设置。</p><p><img   class="lazyload-img" src="https://cdn.jsdelivr.net/gh/MyBlog-GitHub/image-upload@main/uPic/ak0J1J.png" srcset="https://cdn.jsdelivr.net/gh/HexoPlusPlus/CDN@db63c79/loading.gif" data-srcset="https://cdn.jsdelivr.net/gh/MyBlog-GitHub/image-upload@main/uPic/ak0J1J.png"  alt="开发者设置" ></p><p>点击菜单栏中的「Personal access tokens」进入令牌设置。</p><p><img   class="lazyload-img" src="https://cdn.jsdelivr.net/gh/MyBlog-GitHub/image-upload@main/uPic/ZqiWw8.png" srcset="https://cdn.jsdelivr.net/gh/HexoPlusPlus/CDN@db63c79/loading.gif" data-srcset="https://cdn.jsdelivr.net/gh/MyBlog-GitHub/image-upload@main/uPic/ZqiWw8.png"  alt="个人令牌" ></p><p>点击「Generate new token」新建一个令牌。</p><p><img   class="lazyload-img" src="https://cdn.jsdelivr.net/gh/MyBlog-GitHub/image-upload@main/uPic/JCHxQx.png" srcset="https://cdn.jsdelivr.net/gh/HexoPlusPlus/CDN@db63c79/loading.gif" data-srcset="https://cdn.jsdelivr.net/gh/MyBlog-GitHub/image-upload@main/uPic/JCHxQx.png"  alt="新建令牌" ></p><p>勾选全部的权限，名称随意。</p><p>并点击「Generate token」完成生成。</p><p><img   class="lazyload-img" src="https://cdn.jsdelivr.net/gh/MyBlog-GitHub/image-upload@main/uPic/6rzspL.png" srcset="https://cdn.jsdelivr.net/gh/HexoPlusPlus/CDN@db63c79/loading.gif" data-srcset="https://cdn.jsdelivr.net/gh/MyBlog-GitHub/image-upload@main/uPic/6rzspL.png"  alt="生成令牌" ></p><p>记得保存好这个令牌，它不会再次出现。</p><hr><h2 id="新建仓库"><a href="#新建仓库" class="headerlink" title="新建仓库"></a>新建仓库</h2><p>使用 GitHub 新建一个存放 Hexo 文件的仓库，<strong>要选私有仓库</strong>！</p><p><strong>不要勾选</strong>任何的初始化仓库选项！</p><p>在 Hexo 根目录中删除 <code>.git</code> 文件夹(隐藏文件夹)，删除主题目录下的 <code>.git</code> 文件夹。</p><p>然后在 Hexo 根目录下使用 <code>cmd</code> 或终端运行以下命令：</p><pre><code class="hljs bash">git init <span class="hljs-comment"># 新建 Git 仓库</span>git add -A  <span class="hljs-comment"># 暂存所有文件</span>git commit -m <span class="hljs-string">&quot;Create&quot;</span> <span class="hljs-comment"># 提交更新</span>git remote add origin https://github.com/用户名/新建的私有仓库名.git <span class="hljs-comment"># 新增远程链接</span>git push -u origin master <span class="hljs-comment"># 推送至远程仓库</span></code></pre><hr><h2 id="配置-Github-Action"><a href="#配置-Github-Action" class="headerlink" title="配置 Github Action"></a>配置 Github Action</h2><p>进入仓库页面，点击「Action」，点击「 set up a workflow yourself 」。</p><p><img   class="lazyload-img" src="https://cdn.jsdelivr.net/gh/MyBlog-GitHub/image-upload@main/uPic/P5LacM.png" srcset="https://cdn.jsdelivr.net/gh/HexoPlusPlus/CDN@db63c79/loading.gif" data-srcset="https://cdn.jsdelivr.net/gh/MyBlog-GitHub/image-upload@main/uPic/P5LacM.png"  alt="新建 WorkFlow" ></p><p>在左侧代码编辑器中将下方提供的代码粘贴进入代码框。</p><p>请仔细阅读注释，修改最后几行的提交设置。</p><p>确认无误后点击右上角的「Start Commit」。</p><blockquote><p>此处注意！「公开的仓库名」是生成后文件提交的公开仓库，供「GitHub Pages」「Vercel」等服务使用！</p></blockquote><pre><code class="hljs yaml"><span class="hljs-attr">name:</span> <span class="hljs-string">Deploy</span> <span class="hljs-comment"># 部署</span> <span class="hljs-attr">on:</span> <span class="hljs-comment"># 触发条件</span>  <span class="hljs-attr">push:</span>    <span class="hljs-attr">branches:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">master</span> <span class="hljs-comment"># 推送到 master 分支</span>   <span class="hljs-attr">release:</span>    <span class="hljs-attr">types:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">published</span> <span class="hljs-comment"># 推送新版本号</span>   <span class="hljs-attr">workflow_dispatch:</span> <span class="hljs-comment"># 手动触发</span> <span class="hljs-attr">jobs:</span>  <span class="hljs-attr">build:</span>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span>     <span class="hljs-attr">steps:</span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Checkout</span> <span class="hljs-comment"># Checkout 仓库</span>      <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v2</span>      <span class="hljs-attr">with:</span>        <span class="hljs-attr">ref:</span> <span class="hljs-string">master</span>     <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Setup</span> <span class="hljs-string">Node</span> <span class="hljs-comment"># 安装 Node.js</span>      <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/setup-node@v1</span>      <span class="hljs-attr">with:</span>        <span class="hljs-attr">node-version:</span> <span class="hljs-string">&quot;12.x&quot;</span>     <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Install</span> <span class="hljs-string">Hexo</span> <span class="hljs-comment"># 安装 Hexo</span>      <span class="hljs-attr">run:</span> <span class="hljs-string">|</span>        <span class="hljs-string">npm</span> <span class="hljs-string">install</span> <span class="hljs-string">hexo-cli</span> <span class="hljs-string">-g</span>            <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Cache</span> <span class="hljs-string">Modules</span> <span class="hljs-comment"># 缓存 Node 插件</span>      <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/cache@v1</span>      <span class="hljs-attr">id:</span> <span class="hljs-string">cache-modules</span>      <span class="hljs-attr">with:</span>        <span class="hljs-attr">path:</span> <span class="hljs-string">node_modules</span>        <span class="hljs-attr">key:</span> <span class="hljs-string">$&#123;&#123;runner.OS&#125;&#125;-$&#123;&#123;hashFiles(&#x27;**/package-lock.json&#x27;)&#125;&#125;</span>     <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Install</span> <span class="hljs-string">Dependencies</span> <span class="hljs-comment"># 如果没有缓存或 插件有更新，则安装插件</span>      <span class="hljs-attr">if:</span> <span class="hljs-string">steps.cache-modules.outputs.cache-hit</span> <span class="hljs-type">!=</span> <span class="hljs-string">&#x27;true&#x27;</span>      <span class="hljs-attr">run:</span> <span class="hljs-string">|</span> <span class="hljs-comment"># 如果仓库里没有 package-lock.json，上传一下，npm ci 必须要有 package-lock.json</span>        <span class="hljs-string">npm</span> <span class="hljs-string">ci</span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Generate</span> <span class="hljs-comment"># 生成</span>      <span class="hljs-attr">run:</span> <span class="hljs-string">|</span>        <span class="hljs-string">hexo</span> <span class="hljs-string">clean</span>        <span class="hljs-string">hexo</span> <span class="hljs-string">generate</span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Deploy</span> <span class="hljs-comment"># 部署</span>      <span class="hljs-attr">run:</span> <span class="hljs-string">|</span>        <span class="hljs-string">git</span> <span class="hljs-string">config</span> <span class="hljs-string">--global</span> <span class="hljs-string">user.name</span> <span class="hljs-string">&quot;HiFun&quot;</span>        <span class="hljs-string">git</span> <span class="hljs-string">config</span> <span class="hljs-string">--global</span> <span class="hljs-string">user.email</span> <span class="hljs-string">&quot;omycoke@outlook.com&quot;</span>        <span class="hljs-string">export</span> <span class="hljs-string">TZ=&#x27;Asia/Shanghai&#x27;</span>        <span class="hljs-string">cd</span> <span class="hljs-string">public/</span>        <span class="hljs-string">git</span> <span class="hljs-string">init</span>        <span class="hljs-string">git</span> <span class="hljs-string">add</span> <span class="hljs-string">-A</span>        <span class="hljs-string">git</span> <span class="hljs-string">commit</span> <span class="hljs-string">-m</span> <span class="hljs-string">&quot;Create by workflows&quot;</span>        <span class="hljs-string">git</span> <span class="hljs-string">remote</span> <span class="hljs-string">add</span> <span class="hljs-string">origin</span> [<span class="hljs-string">https://令牌@github.com/用户名/公开的仓库名</span>]        <span class="hljs-string">git</span> <span class="hljs-string">push</span> <span class="hljs-string">origin</span> <span class="hljs-string">master</span> <span class="hljs-string">-f</span></code></pre><p><img   class="lazyload-img" src="https://cdn.jsdelivr.net/gh/MyBlog-GitHub/image-upload@main/uPic/n65GGW.png" srcset="https://cdn.jsdelivr.net/gh/HexoPlusPlus/CDN@db63c79/loading.gif" data-srcset="https://cdn.jsdelivr.net/gh/MyBlog-GitHub/image-upload@main/uPic/n65GGW.png"  alt="配置 WorkFlow" ></p><hr><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>每次更改完文件过后，在 Hexo 根目录运行以下命令：</p><pre><code class="hljs bash">git add -Agit commit -m <span class="hljs-string">&quot;Update&quot;</span>git push origin master</code></pre><p>也可直接在仓库中 改文件/写博文 效果一样，GitHub 都会为你自动生成文件。</p>]]></content:encoded>
      
      
      <category domain="https://www.yfun.top/categories/%E6%9E%81%E5%AE%A2/">极客</category>
      
      
      <category domain="https://www.yfun.top/tags/%E5%8D%9A%E5%AE%A2/">博客</category>
      
      <category domain="https://www.yfun.top/tags/Hexo/">Hexo</category>
      
      <category domain="https://www.yfun.top/tags/GitHub/">GitHub</category>
      
      
      <comments>https://www.yfun.top/posts/2241387868.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>免费的图床</title>
      <link>https://www.yfun.top/posts/3867215122.html</link>
      <guid>https://www.yfun.top/posts/3867215122.html</guid>
      <pubDate>Fri, 27 Nov 2020 08:45:00 GMT</pubDate>
      
      <description>本文将介绍一些免费的图床，可以供博客/日常使用。</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文将介绍一些<strong>免费</strong>的图床，可以供博客/日常使用。</p><p>每个图床都会给出测试链接供测试，无法访问或图片丢失则代表图床失效。</p><h1 id="公共图床"><a href="#公共图床" class="headerlink" title="公共图床"></a>公共图床</h1><h2 id="SM-MS"><a href="#SM-MS" class="headerlink" title="SM.MS"></a>SM.MS</h2><p><a href="https://sm.ms/">https://sm.ms</a></p><p>曾经图床的域名有备案并使用国内 CDN，但后来因为滥用被吊销。</p><p>现在使用的是 CloudFlare，国内访问<strong>效果不好</strong>甚至无法访问，不建议使用。</p><p>测试图片：</p><blockquote><p>为避免影响访问速度，此处使用超链接，点击即可看到。</p></blockquote><p><a href="https://i.loli.net/2020/11/27/qNudBVIcGHe14vm.jpg">SM.MS 测试图片</a></p><hr><h2 id="Imgur"><a href="#Imgur" class="headerlink" title="Imgur"></a>Imgur</h2><p><a href="https://imgur.com/">https://imgur.com</a></p><p>国外一家图片托管服务商，你可以选择注册或不注册，同样的，拖拽上传，永久保留，其SLA有着相当高的保证。</p><p>然而很可惜的是，Imgur 并不能在国内正常访问。你也可以尝试使用 <a href="#%E4%BB%A3%E7%90%86">#代理</a> 解决</p><p>测试图片：</p><blockquote><p>为避免影响访问速度，此处使用超链接，点击即可看到。</p></blockquote><p><a href="https://i.imgur.com/NATHKc2.jpeg">Imgur 测试图片</a></p><hr><h2 id="去不图床"><a href="#去不图床" class="headerlink" title="去不图床"></a>去不图床</h2><p><a href="https://7bu.top/">https://7bu.top/</a></p><p>由<a href="https://dusays.com/241/">杜老师</a>提供的个人公益图床，存储于阿里和腾讯的对象存储。</p><p>官方保证 SLA&gt;=99% ，目前来看是一个不错的选择。</p><p>当然，毕竟是个人维护的图床，能不能永久撑下去还是个问题。</p><p>如果您需要搭配 PicGo/uPic，请参考以下的配置：</p><pre><code class="hljs plain">接口地址：https:&#x2F;&#x2F;7bu.top&#x2F;api&#x2F;uploadPOST 参数：image回调 JSON：data.url</code></pre><p>测试图片：</p><p><img   class="lazyload-img" src="https://7.dusays.com/2020/11/27/6689e9310134b.jpg" srcset="https://cdn.jsdelivr.net/gh/HexoPlusPlus/CDN@db63c79/loading.gif" data-srcset="https://7.dusays.com/2020/11/27/6689e9310134b.jpg"  alt="去不图床" ></p><blockquote><p>去不图床所使用的 CDN 面向的是中国大陆，海外大概率解析到一些很辣鸡的节点。</p></blockquote><hr><h2 id="路过图床"><a href="#路过图床" class="headerlink" title="路过图床"></a>路过图床</h2><p><a href="https://imgchr.com/">https://imgchr.com</a></p><p>支持永久存储图片，全球CDN加速。官方宣称『图床从2011年至今都稳定运行』。</p><p>测试图片：</p><p><img   class="lazyload-img" src="https://s3.ax1x.com/2020/11/27/DrM4XQ.jpg" srcset="https://cdn.jsdelivr.net/gh/HexoPlusPlus/CDN@db63c79/loading.gif" data-srcset="https://s3.ax1x.com/2020/11/27/DrM4XQ.jpg"  alt="路过图床" ></p><hr><h2 id="Postimage"><a href="#Postimage" class="headerlink" title="Postimage"></a>Postimage</h2><p><a href="https://postimage.org/">https://postimage.org/</a></p><p>Postimage 是一款来自国外的图床工具，支持按照一定大小缩放图片及设置图片自动删除。</p><p>在上传完成后，Postimage 会为你生成多种链接格式以满足不同需求。</p><p>Postimage 还会生成一个用于删除当前图片的链接，你只要访问那个链接即可将图片从服务器上删除。</p><p>测试图片：</p><p><img   class="lazyload-img" src="https://i.postimg.cc/CF6g03Jx/th.jpg?dl=1" srcset="https://cdn.jsdelivr.net/gh/HexoPlusPlus/CDN@db63c79/loading.gif" data-srcset="https://i.postimg.cc/CF6g03Jx/th.jpg?dl=1"  alt="Postimage" ></p><hr><h1 id="折腾"><a href="#折腾" class="headerlink" title="折腾"></a>折腾</h1><h2 id="GitHub-jsDelivr"><a href="#GitHub-jsDelivr" class="headerlink" title="GitHub + jsDelivr"></a>GitHub + jsDelivr</h2><p><strong>网上有许多的教程，此处不再演示。</strong></p><p>jsDelivr 非常稳定，国外使用 CloudFlare，国内有网宿节点，速度非常之快。</p><p>测试图片：</p><p><img   class="lazyload-img" src="https://cdn.jsdelivr.net/gh/MyBlog-GitHub/image-upload@main/uPic/th.jpg" srcset="https://cdn.jsdelivr.net/gh/HexoPlusPlus/CDN@db63c79/loading.gif" data-srcset="https://cdn.jsdelivr.net/gh/MyBlog-GitHub/image-upload@main/uPic/th.jpg"  alt="jsDelivr" ></p><hr><h2 id="NPM-镜像"><a href="#NPM-镜像" class="headerlink" title="NPM + 镜像"></a>NPM + 镜像</h2><p>我们可以使用 NPM 作为图床的储存。</p><p>再搭配上各种镜像调用，速度扛扛滴。</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><blockquote><p>您应该拥有基本的 <code>npm</code> 环境，如没有，请安装。<br/><br>安装教程可以参阅互联网，有很多可供参考。</p></blockquote><p>首先，新建一个文件夹存放文件。</p><p>然后打开 <code>cmd</code> 或 终端，进入目录并输入以下命令 <strong>登录 NPM</strong>  ：</p><pre><code class="hljs bash">npm login</code></pre><blockquote><p>如果没有账号的，请前往 <a href="https://npmjs.com/">NPM</a> 注册账号</p></blockquote><p>紧接着输入以下命令：</p><pre><code class="hljs bash">npm init <span class="hljs-comment"># 生成包文件</span>npm publish <span class="hljs-comment"># 发布包</span></code></pre><p>请注意，如果你之前用过淘宝镜像，那么请先手动切回官方源：</p><pre><code class="hljs bash">npm config <span class="hljs-built_in">set</span> registry https://registry.npmjs.org</code></pre><p>每次更新完包内存放的图片后，你应该修改 <code>package.json</code> 文件内的版本号（向上增加），然后再次运行 <code>npm publish</code> 发布包。</p><h3 id="推荐的镜像"><a href="#推荐的镜像" class="headerlink" title="推荐的镜像"></a>推荐的镜像</h3><pre><code class="hljs bash">https://cdn.jsdelivr.net/npm/  <span class="hljs-comment"># jsDelivr，网宿节点</span>https://unpkg.zhimg.com/ <span class="hljs-comment"># 知乎，阿里节点</span>https://code.bdstatic.com/npm/ <span class="hljs-comment"># 百度，网宿节点【拉取慢，不推荐】</span>https://shadow.elemecdn.com/npm/ <span class="hljs-comment"># 饿了么，网宿节点</span></code></pre><pre><code class="hljs bash">[镜像链接]/[包名]@[版本]/[文件名]<span class="hljs-comment"># https://cdn.jsdelivr.net/npm/mdt-for-typecho@0.4.2/screenshot.png</span><span class="hljs-comment"># https://unpkg.zhimg.com/mdt-for-typecho@0.4.2/screenshot.png</span><span class="hljs-comment"># https://code.bdstatic.com/npm/mdt-for-typecho@0.4.2/screenshot.png</span><span class="hljs-comment"># https://shadow.elemecdn.com/npm/mdt-for-typecho@0.4.2/screenshot.png</span></code></pre><h3 id="测试图片"><a href="#测试图片" class="headerlink" title="测试图片"></a>测试图片</h3><blockquote><p>图片太多，这里使用超链接，点击就可以看到。</p></blockquote><p>jsDelivr：<a href="https://cdn.jsdelivr.net/npm/mdt-for-typecho@0.4.2/screenshot.png">jsDelivr+NPM</a></p><p>知乎：<a href="https://unpkg.zhimg.com/mdt-for-typecho@0.4.2/screenshot.png">知乎+NPM</a></p><p>百度：<a href="https://code.bdstatic.com/npm/mdt-for-typecho@0.4.2/screenshot.png">百度+NPM</a></p><p>饿了么：<a href="https://shadow.elemecdn.com/npm/mdt-for-typecho@0.4.2/screenshot.png">饿了么+NPM</a></p><hr><h2 id="LeanCloud"><a href="#LeanCloud" class="headerlink" title="LeanCloud"></a>LeanCloud</h2><p><a href="https://leancloud.cn/">https://leancloud.cn</a> / <a href="https://leancloud.app/">https://leancloud.app</a><br>注册一个 LeanCloud 账号，此处不再赘述。</p><p>创建一个 App，进入 <code>存储 -&gt; 文件</code>，点击「上传」并上传图片。</p><p>上传成功后会在文件列表中显示，在列表中我们可以看到 URL 地址。</p><p><img   class="lazyload-img" src="https://cdn.jsdelivr.net/gh/MyBlog-GitHub/image-upload@main/uPic/tlxdgw.png" srcset="https://cdn.jsdelivr.net/gh/HexoPlusPlus/CDN@db63c79/loading.gif" data-srcset="https://cdn.jsdelivr.net/gh/MyBlog-GitHub/image-upload@main/uPic/tlxdgw.png"  alt="上传完成" ></p><p>测试链接：</p><blockquote><p>笔者使用国际版，为避免拖慢网站加载速度，使用超链接，点击即可看到。</p></blockquote><p><a href="https://lc-gluttony.s3.amazonaws.com/lej8uP461WyF/ed16a23d417ffa0acf55.jpg/th.jpg">LeanCloud 测试链接 (国际版)</a></p><hr><h2 id="UniCloud"><a href="#UniCloud" class="headerlink" title="UniCloud"></a>UniCloud</h2><p><a href="https://unicloud.dcloud.net.cn/">https://unicloud.dcloud.net.cn/</a></p><p>注册一个 UniCloud 账号并登录，此处不再赘述。</p><p>创建一个服务空间，选择『阿里云』并起个名字。（选择阿里云不收费）</p><p>进入「云存储」，点击「上传文件」。</p><p><img   class="lazyload-img" src="https://cdn.jsdelivr.net/gh/MyBlog-GitHub/image-upload@main/uPic/2PFj2g.png" srcset="https://cdn.jsdelivr.net/gh/HexoPlusPlus/CDN@db63c79/loading.gif" data-srcset="https://cdn.jsdelivr.net/gh/MyBlog-GitHub/image-upload@main/uPic/2PFj2g.png"  alt="上传文件" ></p><p>点击右侧的「详情」即可查看图片地址，预览等信息。<br><img   class="lazyload-img" src="https://cdn.jsdelivr.net/gh/MyBlog-GitHub/image-upload@main/uPic/iYKvJz.png" srcset="https://cdn.jsdelivr.net/gh/HexoPlusPlus/CDN@db63c79/loading.gif" data-srcset="https://cdn.jsdelivr.net/gh/MyBlog-GitHub/image-upload@main/uPic/iYKvJz.png"  alt="进入详情" ></p><p>测试图片：</p><h2 id=""><a href="#" class="headerlink" title=""></a><img   class="lazyload-img" src="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-aliyun-qvxxidugllx169a140/51632140-309a-11eb-8a36-ebb87efcf8c0.jpg" srcset="https://cdn.jsdelivr.net/gh/HexoPlusPlus/CDN@db63c79/loading.gif" data-srcset="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-aliyun-qvxxidugllx169a140/51632140-309a-11eb-8a36-ebb87efcf8c0.jpg"  alt="UniCloud" ></h2><h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>Imgur 在国内已经无法访问了，但是，我们可以利用服务器代理啊！</p><pre><code class="hljs bash">https://search.pstatic.net/common/?src= <span class="hljs-comment"># 国内网宿，只能加载特定图床图片如 Imgur [1]</span>https://imageproxy.pimg.tw/resize?url= <span class="hljs-comment"># Akamai 节点，无限制 [2]</span>https://images.weserv.nl/?url= <span class="hljs-comment"># CloudFlare 节点 [3]</span>https://pic1.xuehuaimg.com/proxy/ <span class="hljs-comment"># CloudFlare 节点 [4]</span></code></pre><p>我们就以代理 Imgur 的图片为例，原链接：<a href="https://i.imgur.com/NATHKc2.jpeg">https://i.imgur.com/NATHKc2.jpeg</a></p><pre><code class="hljs bash">https://search.pstatic.net/common/?src=https://i.imgur.com/NATHKc2.jpeghttps://imageproxy.pimg.tw/resize?url=https://i.imgur.com/NATHKc2.jpeghttps://images.weserv.nl/?url=https://i.imgur.com/NATHKc2.jpeghttps://pic1.xuehuaimg.com/proxy/https://i.imgur.com/NATHKc2.jpeg</code></pre><p>测试图片：</p><blockquote><p>图片太多，这里使用超链接，点击就可以看到。</p></blockquote><blockquote><p>此处的序号对应上方代理列表的序号</p></blockquote><p><a href="https://search.pstatic.net/common/?src=https://i.imgur.com/NATHKc2.jpeg">[1]</a></p><p><a href="https://imageproxy.pimg.tw/resize?url=https://i.imgur.com/NATHKc2.jpeg">[2]</a></p><p><a href="https://images.weserv.nl/?url=https://i.imgur.com/NATHKc2.jpeg">[3]</a></p><p><a href="https://pic1.xuehuaimg.com/proxy/https://i.imgur.com/NATHKc2.jpeg">[4]</a></p>]]></content:encoded>
      
      
      <category domain="https://www.yfun.top/categories/%E6%9E%81%E5%AE%A2/">极客</category>
      
      
      <category domain="https://www.yfun.top/tags/%E5%8D%9A%E5%AE%A2/">博客</category>
      
      <category domain="https://www.yfun.top/tags/%E5%9B%BE%E5%BA%8A/">图床</category>
      
      
      <comments>https://www.yfun.top/posts/3867215122.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>使用 Vercel 部署静态网站</title>
      <link>https://www.yfun.top/posts/2979788395.html</link>
      <guid>https://www.yfun.top/posts/2979788395.html</guid>
      <pubDate>Mon, 23 Nov 2020 10:22:13 GMT</pubDate>
      
      <description>本文将介绍使用 Vercel 部署静态网站</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="注册账号"><a href="#注册账号" class="headerlink" title="注册账号"></a>注册账号</h2><p>使用浏览器访问：<a href="https://vercel.com/signup">https://vercel.com/signup</a></p><p>点击「Cotinue with GitHub」并使用 GitHub 账号注册。</p><p><img   class="lazyload-img" src="https://cdn.jsdelivr.net/gh/MyBlog-GitHub/image-upload@main/uPic/YzQIUy.png" srcset="https://cdn.jsdelivr.net/gh/HexoPlusPlus/CDN@db63c79/loading.gif" data-srcset="https://cdn.jsdelivr.net/gh/MyBlog-GitHub/image-upload@main/uPic/YzQIUy.png"  alt="使用 GitHub 登录" ></p><details><summary>无法注册账号？</summary>Vercel 不支持 163/QQ 等国内邮箱的注册，请使用 <a href="https://outlook.live.com" target="_blank">Outlook 邮箱</a> 再次注册 GitHub 后使用新 GitHub 账号注册！</details><hr><h2 id="创建代码仓库"><a href="#创建代码仓库" class="headerlink" title="创建代码仓库"></a>创建代码仓库</h2><p>新建 GitHub 代码仓库，并在代码仓库中新建 <code>index.html</code> 文件，这将作为首页。</p><p>在 <code>index.html</code> 文件中填写基本的代码内容，如：</p><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Test Page<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>This page is for test.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><hr><h2 id="使用-Vercel-部署"><a href="#使用-Vercel-部署" class="headerlink" title="使用 Vercel 部署"></a>使用 Vercel 部署</h2><p>点击<a href="https://vercel.com/dashboard">控制台</a>右上角的「Import Project」</p><p><img   class="lazyload-img" src="https://cdn.jsdelivr.net/gh/MyBlog-GitHub/image-upload@main/uPic/ZprWh4.png" srcset="https://cdn.jsdelivr.net/gh/HexoPlusPlus/CDN@db63c79/loading.gif" data-srcset="https://cdn.jsdelivr.net/gh/MyBlog-GitHub/image-upload@main/uPic/ZprWh4.png"  ></p><p>点击「Import Git Repository」下方的「Continue」</p><p><img   class="lazyload-img" src="https://cdn.jsdelivr.net/gh/MyBlog-GitHub/image-upload@main/uPic/hgeaBV.png" srcset="https://cdn.jsdelivr.net/gh/HexoPlusPlus/CDN@db63c79/loading.gif" data-srcset="https://cdn.jsdelivr.net/gh/MyBlog-GitHub/image-upload@main/uPic/hgeaBV.png"  ></p><p>输入 GitHub 仓库的地址并点击「Continue」</p><p><img   class="lazyload-img" src="https://cdn.jsdelivr.net/gh/MyBlog-GitHub/image-upload@main/uPic/Uabikg.png" srcset="https://cdn.jsdelivr.net/gh/HexoPlusPlus/CDN@db63c79/loading.gif" data-srcset="https://cdn.jsdelivr.net/gh/MyBlog-GitHub/image-upload@main/uPic/Uabikg.png"  ></p><p>经过基本配置后，项目就会自动部署。</p><p>点击项目控制台的「View Domain」进入域名配置</p><p><img   class="lazyload-img" src="https://cdn.jsdelivr.net/gh/MyBlog-GitHub/image-upload@main/uPic/lLYsWv.png" srcset="https://cdn.jsdelivr.net/gh/HexoPlusPlus/CDN@db63c79/loading.gif" data-srcset="https://cdn.jsdelivr.net/gh/MyBlog-GitHub/image-upload@main/uPic/lLYsWv.png"  ></p><p>默认会提供 <code>*.vercel.app</code> 免费域名，也可以免费添加自己的域名。</p><p><img   class="lazyload-img" src="https://cdn.jsdelivr.net/gh/MyBlog-GitHub/image-upload@main/uPic/ek0ZYY.png" srcset="https://cdn.jsdelivr.net/gh/HexoPlusPlus/CDN@db63c79/loading.gif" data-srcset="https://cdn.jsdelivr.net/gh/MyBlog-GitHub/image-upload@main/uPic/ek0ZYY.png"  ></p><blockquote><p>目前新项目已经更换为 <code>*.vercel.app</code> 域名，如仍需要 <code>*.now.sh</code> 域名，可以直接填写，实测可以使用。<br/><br>例如我需要使用 <code>test-page-123.now.sh</code> 域名，那么我只需要在自定义域名处填写并点击「Add」即可。</p></blockquote>]]></content:encoded>
      
      
      <category domain="https://www.yfun.top/categories/%E6%9E%81%E5%AE%A2/">极客</category>
      
      
      <category domain="https://www.yfun.top/tags/%E5%8D%9A%E5%AE%A2/">博客</category>
      
      
      <comments>https://www.yfun.top/posts/2979788395.html#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
